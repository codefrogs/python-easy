So now we have a signal handler, we want to show one possible
problem. We want to see what we can do if our main function is
blocking, in other words awaiting some IO operation.

Try it out:
1. Run the script.
2. Try to CTRL-C to terminate it.

It will cancel the tasks, but then 'wait in main' for 10 seconds
effectively blocking the shutdown.

You can cancel a process with: 'kill -9 <ID>'

Note: We are not trying to solve anything in this script. We
are just demonstrating an issue.

Let's look at the output when we terminate. (For brevity some details are removed):

1. Cancelling task(Task-1)
2. Traceback (most recent call last):
3.   File ".../07_main_blocking.py", line 13, in main
4.     await asyncio.sleep(10)
5.   File ".../python3.10/asyncio/tasks.py", line 605, in sleep
6.     return await future
7. asyncio.exceptions.CancelledError
8.
9. During handling of the above exception, another exception occurred:...

At line 1, we see that some task, called Task-1 is being cancelled. An internal
task generated by asyncio.
The signal handler tells the task to cancel.
This then causes our coroutine 'asyncio.sleep' to throw an exception.
The exception isn't cause.
Then main throws an exception, and the application halts.

Let's catch the exception in our next script.
